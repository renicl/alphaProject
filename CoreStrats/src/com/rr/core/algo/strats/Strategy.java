/*******************************************************************************
 * Copyright (c) 2015 Low Latency Trading Limited  :  Author Richard Rose
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at	http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,  software distributed under the License 
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
 *******************************************************************************/
package com.rr.core.algo.strats;

import com.rr.core.algo.base.StrategyDefinition;
import com.rr.core.algo.strats.BaseAlgo.StratOrdStates;
import com.rr.core.component.SMTControllableComponent;
import com.rr.core.lang.ReusableString;
import com.rr.core.lang.ZString;
import com.rr.core.log.Logger;
import com.rr.core.model.Book;
import com.rr.core.model.BookListener;
import com.rr.core.model.Message;
import com.rr.core.model.MessageHandler;
import com.rr.core.session.Session;
import com.rr.core.session.Throttler;
import com.rr.core.thread.NonBlockingWorker;
import com.rr.model.generated.internal.events.interfaces.NewOrderSingle;
import com.rr.model.generated.internal.events.interfaces.StrategyState;
import com.rr.model.generated.internal.type.OrdType;
import com.rr.model.generated.internal.type.Side;
import com.rr.model.generated.internal.type.TimeInForce;
import com.rr.om.router.OrderRouter;


/**
 * Running instance of an algo
 * 
 * isA NonBlockingWorker so instance can be directly registered with a NonBlockingMessageHandlingMultiplexor
 * in effect giving the algo a timeslice of the multiplexors hot running control thread
 * 
 *  
 */
public interface Strategy<T extends Book> extends SMTControllableComponent, NonBlockingWorker {
    
    public enum StratRunState { 
        Initial(false), 
        Running(true), 
        SemiPaused(true), 
        FullyPaused(false);
        
        private final boolean _isActiveWorkerState;

        StratRunState( boolean isActiveWorkerState ) {
            _isActiveWorkerState = isActiveWorkerState;
        }

        public boolean isActiveWorkerState() {
            return _isActiveWorkerState;
        }
    }

    /**
     * ExchangeHandler one instance per book ... saves map lookup on book
     */
    public interface ExchangeHandler<T extends Book> extends MessageHandler {

        /**
         * @param tickNanos if event generated by tick then must supply the timestamp tick arrived in system (can get from book)
         *        0 if generated for reasons other than book change .. eg exchange event
         *        
         * @param the tickId generating this order event .. or 0 if not invoked due to book change
         *        
         * @return populated NOS from pool 
         */
        public NewOrderSingle makeNOS( ZString exDest, OrdType ordType, TimeInForce tif, int qty, double price, Side side, long tickNanos, long tickId );

        /**
         * @param side the side to cancel
         * @param dest - the destination that the NOS was sent too, or null to pick up first available dest from router
         * 
         * @return cancel request from pool 
         */
        public void enqueueCancel( Side side, ZString clOrdId, ZString orderId, MessageHandler dest );
        
        /**
         * @return book associated with this handler
         */
        public T getBook();

        /**
         * @return strategy instrument state for the instrument associated with this handler
         */
        public StratInstrumentStateWrapper<T> getStratInstState();
        
        /**
         * market data event invoked by exchange inbound thread
         * 
         * should enqueue message for later processing
         * 
         * @param mktMessage message to be processed then recycled
         */
        @Override
        public void handle( Message mktMessage );

        /**
         * process a unit of work from the mkt message queue
         * runs on the strategy control thread
         * @return true if any work performed
         */
        public void doWorkUnit();

        /**
         * @return an index associated with this handler ... used by Strategy for index lookup into arrays
         */
        public int getIndex();

        /**
         * set the book for this handler
         * 
         * @param book
         */
        public void setBook( T book );

        /**
         * @return true if should use detailed trace level logging
         */
        public boolean isTrace();

        /**
         * @return ReusableString for use in the control thread of the strategy
         */
        public ReusableString getTraceMsg();

        /**
         * @return number of entries in the waiting queue to be processed (exchange events)
         */
        public int getCurrQSize();

        /**
         * facilitation method for use in exec ord state handlers
         * @return the strategy owning this exchange handler
         */
        public BaseStrategy<T> getStrategy();
    }

    /**
     * MarketDataHandler one instance per book ... saves map lookup on book
     * 
     * the book specific exchange handler is to be used by the strategy for submitting orders
     * can be obtained from StratInstrumentStateWrapper
     * (should be seperate ex handler instance for each book to avoid inst based map lookups for execRpts)
     * 
     * @param exh
     *
     */
    public interface StratBookAdapter<T extends Book> extends BookListener<T> {
        
        /**
         * @return book associated with this handler
         */
        public T getBook();

        /**
         * @return strategy instrument state for the instrument associated with this handler
         */
        public StratInstrumentStateWrapper<T> getStratInstState();
        
        /**
         * invoked by market data thread to inform of change
         * 
         * should note that work is to be done within the doWorkUnit 
         * 
         * @param book the book thats changed ... should be same as the book assigned to this handler
         */
        @Override
        public void changed( T book );

        /**
         * process a unit of work as identified by the market data handler invoking the changed method
         * runs on the strategy control thread
         * @return true if any work performed
         */
        public void doWorkUnit();

        /**
         * set the book that this handler related too
         */
        public void setBook( T book );
    }

    /**
     * set the owning Algo instance
     * 
     * @param algo
     */
    public void setAlgo( Algo<?> algo );

    public Algo<?> getAlgo();
    
    /**
     * set the StrategyDefintion for this strategy
     * 
     * will autoreflect property entries into member variables as appropriate 
     * 
     * @param def
     */
    public void setStrategyDefinition( StrategyDefinition def );

    public StrategyDefinition getStrategyDefinition();
    
    public StratBookAdapter<T>[] getMarketDataHandlers();
    
    public ExchangeHandler<T>[] getExchangeHandlers();
    
    public StrategyState getStrategyState();
    
    /**
     * process unit of work from exchange queue
     * if none then process unit of work from market data queue
     * invoked on strategy control thread
     */
    @Override
    public void doWorkUnit();

    /**
     * set the router component that sits between strategy and exchange
     *  
     * @param exchangeRouter
     */
    public void setOrderRouter( OrderRouter exchangeRouter );

    /**
     * set the account to use for orders
     * 
     * @param account
     */
    public void setAccount( ZString account );

    /**
     * @param hubSession session to send drop copy exchange events and strat state
     */
    public void setHubSession( Session hubSession );

    /**
     * sets levels of book to snap
     * 
     * @param bookLevels
     */
    public void setBookLevels( int bookLevels );

    /**
     * notifies strategy that book has changed
     * 
     * @param mdh - market data handler that holds book that changed
     * @param stratInstState - strategy state for the instrument 
     */
    public void bookChanged( StratInstrumentStateWrapper<? extends Book> stratInstState );
    
    /**
     * notifies strategy that a market event occurred and has been processed
     * strategy needs check in post process for corrective / additional action
     */
    public void setMarketOrderTerminalEvent( StratInstrumentStateWrapper<? extends Book> stratInstState );


    /**
     * set the state machine used to process execution reports
     * 
     * @param stratOrdStates
     */
    public void setStratOrdStates( StratOrdStates stratOrdStates );

    /**
     * @return strategy state handlers for exec reports
     */
    public StratOrdStates getStratOrdStates();

    /**
     * @return logger for logging messages in current control thread
     */
    public Logger getLogger();

    /**
     * enqueue a message to be dispatched in postProcessing callback of multiplexor
     * @param msg
     */
    public void enqueueForDownDispatch( Message msg );

    /**
     * set an event throttler to limit activity in strategy
     * throttlers are not thread safe so only assign a throttler to be used by strats on one multiplexor
     * 
     * @param t
     */
    public void setThrottler( Throttler t );

    public StratRunState getRunState();

    /**
     * force state to the supplied state
     * @param forcedState
     * @return previous state
     */
    public StratRunState setRunState( StratRunState forcedState );

    /**
     * @return true if this strategy is allowed to trade
     */
    public boolean isTradingAllowed();

    public void dumpInstDetails( ReusableString s );

    /**
     * for use by admin to reset the current slice state ... only for extreme use cases !!
     * 
     * @WARNING DANGEROUS : THIS WILL STOP ANY CATCHUP ATTEMPTS
     */
    public void forceSliceReset();
    
    /**
     * notification that a slice has completed
     */
    public void legSliceCompleted();

    public void setTrace( boolean trace );

    /**
     * @param tradingAllowed if true then strat can send orders to market
     */
    public void setTradingAllowed( boolean tradingAllowed );

    /**
     * @param maxOrderQty maximum order qty for a slice
     */
    public void setMaxOrderQty( int maxOrderQty );

    /**
     * @param minOrderQty minimum order qty for a slice (should be at least the largest of the legs minimum order quantities
     */
    public void setMinOrderQty( int minOrderQty );

    /**
     * @param maxSlices maximum number of slices strategy can make
     */
    public void setMaxSlices( int maxSlices );

    /**
     * @param pnlCutoffThreshold point at which strat must not generate any new slices, eg -10000 means when lost 10K stop trading
     */
    public void setPnlCutoffThreshold( double pnlCutoffThreshold );
}
